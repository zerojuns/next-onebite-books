2024-09-19  1일차
1.3 강의명 : 실습용 백엔드 서버 세팅 : 완료 (superbase 셋팅)
1.4 강의명 : 본격적인 핚습에 앞서

2024-09-22 2일차
2.1 강의명 : Page Router를 소개합니다
2.2 강의명 : 페이지 라우팅 설정하기

쿼리 스트링으로 값 가져오는법
import { useRouter } from "next/router"

const router = useRouter();
const {q} = router.query;

[[...id]] Optional Catch all segment ex) localhost:3000/book/213/123/1411
console.log 시 배열형태로 전달받음

2.3 강의명 : 네비게이팅
2.4 강의명 : 프리페칭

2024-09-23 3일차

2.5 강의명 : Api Router
2.6 강의명 : 스타일링
next js 는 app.tsx 제외한 css import 은 module를 활용해서 구현

2024-09-24 4일차

2.7 강의명 : 글로벌 레이아웃 설정하기
2.8 강의명 : 페이지별 레이아웃 설정하기

2024-09-25 5일차

2.9 강의명 : 한입북스 ui 구현하기

2024-09-26 6일차
2.10 강의명 : 사전렌더링과 데이터페칭
2.11 강의명 : SSR 소개 및 실습
2.12 강의명 : SSR 실습

SSR은 클라이언트와 서버 간의 협력으로 이루어지는 프로세스입니다. 
서버에서는 초기 렌더링을 처리하고 클라이언트에게 완성된 HTML을 제공함으로써 초기 로딩 속도를 개선할 수 있습니다.
이후에는 클라이언트 측 JavaScript 코드가 실행되어 동적인 상호작용을 제공합니다.

동작 과정
클라이언트 요청
사용자가 웹 애플리케이션에 접속하면 클라이언트는 서버에 요청을 전송합니다.
서버에서 데이터 로드
서버는 해당 요청에 필요한 데이터를 로드합니다. 데이터는 API 호출, 데이터베이스 쿼리 등을 통해 가져올 수 있습니다.
컴포넌트 렌더링
서버는 로드한 데이터와 함께 React 컴포넌트를 렌더링합니다. 이때, 컴포넌트는 사용자에게 보여질 최종 HTML을 생성하는데 사용됩니다.
완성된 HTML 반환
서버는 완성된 HTML을 클라이언트에게 반환합니다. 이 HTML에는 컴포넌트가 렌더링된 상태와 필요한 데이터가 포함됩니다.
클라이언트 렌더링
클라이언트는 받은 HTML을 브라우저에 렌더링합니다. 이후에는 클라이언트 측 JavaScript 코드가 실행되어 해당 페이지의 상호작용이 가능해집니다.
페이지가 로드된 이후에는 사용자의 상호작용에 따라 클라이언트 측에서 추가적인 데이터 요청이 발생하고, 필요한 부분만 업데이트됩니다. 이는 일반적인 클라이언트 사이드 렌더링(CSR)과 유사합니다.

SSR의 장점
서버 사이드 렌더링(SSR)의 장점은 다양한 측면에서 애플리케이션의 성능과 사용자 경험을 향상시킬 수 있습니다.

1. 초기 로딩 속도 개선
SSR은 서버에서 렌더링된 완전한 HTML 문서를 클라이언트에게 제공하므로, 사용자는 초기에 전체 페이지를 볼 수 있습니다. 이는 CSR(Client-Side Rendering)과 비교했을 때 초기 로딩 속도가 빠르다는 장점을 가지고 있습니다. 사용자들은 빠른 페이지 로딩을 경험하며, 애플리케이션에 대한 전반적인 성능이 향상됩니다.

2. 검색 엔진 최적화(SEO)
SSR은 서버에서 완전한 HTML 문서를 제공하기 때문에 검색 엔진 크롤러가 콘텐츠를 인덱싱하는 데 용이합니다. 검색 엔진은 CSR에서는 자바스크립트 파일의 로딩을 기다리지 않고 HTML을 크롤링합니다. 따라서 SSR을 사용하면 검색 엔진이 애플리케이션의 콘텐츠를 쉽게 찾고 인덱싱할 수 있습니다. 이로써 검색 결과에 노출되는 가능성이 높아지며, 애플리케이션의 가시성과 유입 경로가 향상됩니다.

3. 소셜 미리보기
소셜 미디어 플랫폼은 URL을 스크랩하여 해당 페이지의 미리보기를 생성합니다. SSR을 사용하면 서버에서 렌더링된 HTML 문서를 제공하므로, 미리보기가 정확하고 풍부한 정보를 포함할 수 있습니다. 이는 사용자가 앱을 공유할 때 미리보기가 정확히 표시되어 사용자들에게 더욱 매력적인 링크를 제공할 수 있습니다.

4. 보안 강화
SSR은 클라이언트 측 자바스크립트 코드를 외부로 노출시키지 않기 때문에 애플리케이션의 보안을 강화하는 데 도움을 줍니다. CSR에서는 클라이언트에게 자바스크립트 파일을 제공하여 실행되기 때문에 악의적인 사용자가 코드를 분석하거나 수정할 수 있는 위험이 존재합니다. SSR은 클라이언트 측에서 실행되는 코드 양을 최소화하여 보안 취약점을 줄여줍니다.

5. 개발 유연성
SSR은 서버 측에서 렌더링되기 때문에 서버 측의 다양한 기능과 환경을 활용할 수 있습니다. 서버 사이드의 언어나 프레임워크, 미들웨어 등 다양한 기술을 자유롭게 사용하여 애플리케이션을 개발할 수 있습니다. 또한, SSR은 클라이언트와 독립적으로 구현되므로 클라이언트 측 기술 변화에 영향을 받지 않고 개발을 진행할 수 있는 장점도 있습니다.

SSR의 단점

서버 부하
SSR은 서버에서 렌더링을 처리하기 때문에 서버의 부하가 증가할 수 있습니다. 많은 요청이 동시에 발생하거나 복잡한 컴포넌트를 렌더링해야 하는 경우 서버의 응답 시간이 증가할 수 있습니다. 적절한 서버 인프라와 캐싱 전략을 사용하여 서버 부하를 완화할 수 있습니다.

초기 구성 복잡성
SSR은 클라이언트와 서버 간의 상호작용이 필요하기 때문에 초기 구성이 상대적으로 복잡할 수 있습니다. 서버 측 라우팅, 데이터 로딩 및 상태 관리 등을 처리해야 하므로 개발자가 더 많은 작업과 공부를 해야 합니다. 이에 대한 복잡성을 줄이기 위해 프레임워크나 라이브러리를 사용하는 것이 도움이 될 수 있습니다.

클라이언트 자원 사용
SSR은 초기 로딩 시에 완전한 HTML 문서를 클라이언트에게 전송합니다. 따라서 초기 로딩에 필요한 자원(HTML, CSS, JavaScript)의 크기가 증가할 수 있습니다. 이는 네트워크 대역폭을 차지하고 초기 로딩 시간을 늘릴 수 있으며, 모바일 사용자들에게는 추가적인 데이터 사용량을 초래할 수도 있습니다.

클라이언트 측 로직 이중화
SSR은 초기 렌더링을 서버에서 처리하기 때문에 클라이언트 측의 자바스크립트 로직과 중복될 수 있습니다. 예를 들어, 페이지 내의 동적 상호작용이나 데이터 변경이 발생하는 경우 서버와 클라이언트 간의 동기화 문제가 발생할 수 있습니다. 이를 해결하기 위해 초기 상태 전달 및 서버와의 데이터 통신을 조율하는 추가 작업이 필요할 수 있습니다.

제한된 클라이언트 기능 사용
SSR은 서버에서 렌더링하기 때문에 클라이언트 측 기능에 제한이 있을 수 있습니다. 일부 브라우저 API나 서드파티 라이브러리 (개인 개발자나 프로젝트 팀, 혹은 업체등에서 개발하는 라이브러리) 는 클라이언트 환경에서만 사용 가능한 경우가 많으므로 서버 사이드에서는 이러한 기능을 사용할 수 없을 수도 있습니다. 이 경우, 클라이언트 측에서 추가적인 로직을 처리해야 할 수 있습니다.